#include <dummy.h>

#include "adc_audio.h"
//80 MHZ clock going into timer 
//16 bit prescaler is used to limit the hardware clock signal to every N tick.
//minimum prescaler value is 2, timer interrupts run at 40 MHZ
//timer properties
//divider : the frequency prescale value
//counter_en : whether the timer’s associated 64-bit counter is enabled (usually true)
//counter_dir : whether the counter is incremented or decremented
//alarm_en : whether the “alarm”, i.e. the counter’s action, is enabled
//auto_reload : whether the counter is reset when the alarm is triggered
portMUX_TYPE DRAM_ATTR timerMux = portMUX_INITIALIZER_UNLOCKED;
TaskHandle_t bufferFullTaskHandler;
hw_timer_t * adcTimer = NULL;
int16_t abuf[AA_BUFFER_SIZE];
int16_t writeBufPos = 0;

int16_t mockData[AA_BUFFER_SIZE] = {2279,2141,1977,1833,1676,1522,1380,1243,1109,987,876,776,687,606,541,500,457,436,440,426,432,477,511,570,637,725,813,921,1034,1170,1293,1444,1599,1742,1901,2065,2196,2379,2494,2669,2814,2970,3112,3275,3422,3592,3701,3835,3931,4025,4075,4095,4095,4086,4029,3959,3851,3738,3603,3477,3293,3163,2999,2855,2697,2553,2392,2236,2087,1935,1770,1625,1459,1311,1189,1052,933,837,733,661,579,523,474,454,421,429,430,455,484,534,585,677,751,855,953,1079,1207,1339,1481,1642,1799,1952,2108,2255,2407,2585,2727,2875,3004,3197,3319,3478,3623,3775,3881,3978,4037,4095,4095,4095,4073,4027,3928,3831,3694,3573,3419,3256,3107,2959,2803,2653,2491,2355,2175,2024,1880,1726,1579,1418,1286,1149,1016,922,807,725,635,573,506,476,442,430,427,436,460,506,552,628,695,794,903,1002,1127,1268,1401,1553,1686,1839,2003,2147,2302,2472,2621,2762,2919,3092,3223,3389,3539,3683,3787,3927,3983,4073,4095,4095,4093,4051,3964,3899,3772,3641,3497,3342,3194,3021,2895,2719,2566,2444,2283,2127,1963,1828,1671,1516,1374,1237,1111,980,875,775,680,605,539,494,447,425,423,425,437,476,509,572,638,723,814,925,1031,1163,1290,1433,1582,1739,1887,2038,2191,2356,2505,2659,2808,2971,3130,3273,3439,3588,3705,3838,3929,4021,4077,4095,4095,4085,4030,3977,3869,3743,3623,3480,3295,3164,2997,2855,2693,2547,2388,2246,2089,1943,1779,1630,1468,1337,1197,1070,953,849,748,675,585,534,482,457,427,432,435,459,489,540,589,681,747,859,957,1082,1205,1350,1487,1644,1783,1943,2099,2259,2403,2565,2713,2874,3018,3177,3316,3496,3625,3768,3881,3993,4052,4095,4095,4095,4087,4030,3928,3848,3695,3563,3423,3263,3104,2961,2809,2649,2487,2356,2191,2027,1883,1723,1557,1435,1288,1157,1030,920,809,729,646,572,508,475,442,436,428,440,462,506,555,636,685,793,885,1008,1139,1263,1391,1545,1688,1848,1993,2153,2313,2474,2617,2791,2915,3080,3221,3379,3517,3668,3795,3912,3997,4083,4095,4095,4093,4063,3989,3912,3782,3645,3497,3348,3193,3049,2888,2736,2595,2439,2279,2127,1977,1833,1672,1517,1370,1231,1111,987,875,777,680,606,541,495,455,431,424,429,435,473,508,575,635,726,809,921,1031,1165,1293,1449,1588,1755,1886,2061,2202,2356,2507,2661,2811,2971,3115,3277,3427,3599,3723,3852,3946,4031,4087,4095,4095,4095,4049,3986,3864,3742,3599,3467,3308,3155,2991,2861,2695,2540,2377,2238,2087,1938,1775,1619,1461,1334,1177,1067,948,843,745,666,589,536,477,457,427,436,439,463,492,539,599,684,767,863,971,1081,1209,1367,1485,1643,1780,1950,2103,2251,2405,2572,2709,2875,3019,3174,3307,3496,3627,3781,3883,3985,4055,4095,4095,4095,4088,4024,3930,3845,3699,3571,3425,3251,3111,2942,2807,2649,2487,2342,2181,2030,1873,1722,1578,1420,1288,1161,1033,921,806,716,645,568,505,473,441,429,426,435,457,501,549,646,693,787,886,996,1115,1251,1385,1531,1690,1837,2001,2153,2303,2462,2602,2763,2909,3067,3227,3369,3517,3666,3801,3911,3983,4076,4095,4095,4091,4075,3983,3917,3791,3659,3509,3356,3215,3052,2906,2744,2601,2450,2277,2137,1982,1837,1673,1512,1383,1244,1109,989,876,777,681,611,547,500,463,441,429,435,443,487,518,580,651,731,823,937,1036,1167,1295,1449,1605,1751,1893,2043,2206,2367,2515,2661,2815,2981,3113,3277,3431,3574,3708,3836,3947,4037,4069,4095,4095,4095,4025,3965,3865,3736,3593,3477,3302,3160,2999,2857,2698,2550,2395,2235,2084,1933,1769,1627,1459,1335,1189,1061,933,838,739,665,581,533,474,445,419,424,429,447,474,535,584,665,751,858,956,1080,1213,1356,1491,1643,1780,1944,2102,2249,2407,2579,2701,2869,3013,3169,3308,3480,3622,3753,3866,3967,4026,4083,4095,4095,4067,4011,3918,3806,3679,3547,3401,3247,3095,2941,2798,2643,2483,2340,2172,2031,1869,1712,1567,1419,1278,1150,1011,907,799,717,632,565,501,463,436,427,423,434,455,499,544,611,690,787,876,996,1109,1246,1383,1527,1679,1839,1982,2143,2296,2463,2603,2751,2907,3083,3209,3363,3509,3675,3789,3913,3989,4055,4095,4095,4087,4051,3987,3899,3771,3643,3497,3335,3191,3049,2889,2740,2589,2429,2275,2121,1977,1817,1675,1518,1364,1235,1095,986,877,779,692,606,542,494,453,439,427,427,443,478,518,573,650,733,812,931,1037,1160,1289,1447,1583,1749,1891,2069,2188,2359,2503,2669,2812,2987,3144,3283,3423,3596,3705,3850,3944,4041,4084,4095,4095,4095,4047,3968,3863,3749,3607,3477,3308,3167,3007,2861,2696,2553,2395,2247,2090,1926,1779,1628,1463,1340,1187,1067,947,839,743,663,583,531,475,447,423,427,431,454,484,540,588,675,739,859,949,1067,1203,1339,1478,1635,1780,1946,2091,2246,2394,2552,2696,2869,3005,3179,3319,3469,3599,3743,3852,3951,4038,4077,4079,4095,4056,3999,3911,3804,3675,3556,3405,3237,3092,2952,2795,2633,2488,2339,2172,2026,1874,1725,1571,1428,1275,1147,1007,913,798,714,629,567,507,471,441,428,425,443,459,503,533,617,695,783,879,996,1117,1259,1390,1541,1689,1861,2002,2151,2310,2462,2616,2765,2931,3066,3220,3376,3529,3666,3793,3926,3999,4072,4095,4095,4091,4062,3995,3901,3785,3660,3515,3370,3208,3050,2899,2757,2591,2445};
bool isMocking = true;
void onBufferFull(void *params)
{
  while(true)
  {
    uint32_t timerCount = ulTaskNotifyTake(pdFALSE,pdMS_TO_TICKS(100000));
    memcpy(AA_buffer,abuf,sizeof(abuf));
    
    

  }

}

// int IRAM_ATTR local_adc1_read(int channel) {
//     uint16_t adc_value;
//     SENS.sar_meas_start1.sar1_en_pad = (1 << channel); // only one channel is selected
//     while (SENS.sar_slave_addr1.meas_status != 0);
//     SENS.sar_meas_start1.meas1_start_sar = 0;
//     SENS.sar_meas_start1.meas1_start_sar = 1;
//     while (SENS.sar_meas_start1.meas1_done_sar == 0);
//     adc_value = SENS.sar_meas_start1.meas1_data_sar;
//     return adc_value;
// }


void IRAM_ATTR onTimer() {
  portENTER_CRITICAL_ISR(&timerMux);

  abuf[writeBufPos++] = isMocking ? mockData[writeBufPos] : adc1_get_raw(ADC1_CHANNEL_0);
  
  if (writeBufPos >= AA_BUFFER_SIZE) { 
    writeBufPos = 0;

    // Notify adcTask that the buffer is full.
    BaseType_t xHigherPriorityTaskWoken = pdFALSE;
    vTaskNotifyGiveFromISR(bufferFullTaskHandler, &xHigherPriorityTaskWoken);
    if (xHigherPriorityTaskWoken) {
      portYIELD_FROM_ISR();
    }
  }
  portEXIT_CRITICAL_ISR(&timerMux);
}







void AA_setup() {
   
  xTaskCreate(onBufferFull, "Handler Task", 8192, NULL, 1, &bufferFullTaskHandler);
  adcTimer = timerBegin(3, 4, true); // 80 MHz / 80 = 1 MHz hardware clock for easy figuring
  timerAttachInterrupt(adcTimer, &onTimer, true); // Attaches the handler function to the timer 
  timerAlarmWrite(adcTimer, 625, true); // Interrupts when counter == 625, i.e. 32000 times a second
  timerAlarmEnable(adcTimer);
}