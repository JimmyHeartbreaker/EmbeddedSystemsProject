#include "dac_audio.h"
#include "AudioDAC.h"
#include "Shared.h"
#include "arm_math.h"
#include <stdio.h>

namespace Audio::D2AC 
{
  #define BLOCK_SIZE          16
  #define NUM_TAPS_1k            256
  
  arm_fir_instance_f32 S1k;
 

  static float32_t firStateF321k[BLOCK_SIZE + NUM_TAPS_1k - 1]; 
 
 


  AudioDAC dac0(A12);
  void (*copyDataToBufferFPtr)(void*, int);


  bool even=true;
  float coeffs1k[NUM_TAPS_1k] = { -0.000019612501893, -0.000058645149734, -0.000096495060236, -0.000132037349181, -0.000164139324162, -0.000191673242401, -0.000213535418872, -0.000228672784217, -0.000236117313675, -0.000235027960953, -0.000224738886845, -0.000204811930038, -0.000175090488591, -0.000135751325952, -0.000087350341501, -0.000030858100724, 0.000032319059134, 0.000100336223447, 0.000170928667750, 0.000241454587464, 0.000308963042891, 0.000370287032130, 0.000422160122440, 0.000461353522453, 0.000484828948652, 0.000489901219629, 0.000474403291421, 0.000436845512435, 0.000376560303152, 0.000293823315792, 0.000189942445319, 0.000067306866594, -0.000070610440491, -0.000219301475042, -0.000373325965839, -0.000526468287945, -0.000671946069805, -0.000802665244132, -0.000911513561154, -0.000991682024643, -0.001037001469981, -0.001042279713182, -0.001003623480387, -0.000918728778670, -0.000787123564187, -0.000610347544621, -0.000392055725587, -0.000138034843911, 0.000143874945326, 0.000443956953222, 0.000750892987202, 0.001052131577239, 0.001334339844517, 0.001583924982830, 0.001787607188751, 0.001933022294688, 0.002009329526382, 0.002007797896986, 0.001922343905181, 0.001749993525741, 0.001491243021705, 0.001150295869854, 0.000735157023334, 0.000257570729758, -0.000267205979747, -0.000820795423197, -0.001382251277128, -0.001928757515418, -0.002436454265641, -0.002881363955309, -0.003240385260682, -0.003492317556571, -0.003618875055162, -0.003605647830262, -0.003442966611022, -0.003126629692687, -0.002658453577603, -0.002046613979126, -0.001305750470582, -0.000456816143709, 0.000473337108736, 0.001452636978127, 0.002444721520729, 0.003410100434815, 0.004307514670913, 0.005095452739705, 0.005733773814525, 0.006185381042793, 0.006417883713502, 0.006405184342137, 0.006128926518330, 0.005579741615708, 0.004758237193654, 0.003675677035175, 0.002354312074725, 0.000827332693117, -0.000861574371806, -0.002659067367622, -0.004503377492142, -0.006325897265309, -0.008053088974399, -0.009608659754377, -0.010915938299346, -0.011900378652231, -0.012492109402301, -0.012628442265164, -0.012256252661779, -0.011334146677777, -0.009834333682538, -0.007744131811574, -0.005067044242249, -0.001823357388425, 0.001949772627728, 0.006198762114760, 0.010854569756486, 0.015834175549589, 0.021042532248167, 0.026374936132795, 0.031719748819410, 0.036961388880434, 0.041983501759425, 0.046672209221191, 0.050919335683309, 0.054625508393958, 0.057703031598667, 0.060078441488854, 0.061694658633982, 0.062512667432573, 0.062512667432573, 0.061694658633982, 0.060078441488854, 0.057703031598667, 0.054625508393958, 0.050919335683309, 0.046672209221191, 0.041983501759425, 0.036961388880434, 0.031719748819410, 0.026374936132795, 0.021042532248167, 0.015834175549589, 0.010854569756486, 0.006198762114760, 0.001949772627728, -0.001823357388425, -0.005067044242249, -0.007744131811574, -0.009834333682538, -0.011334146677777, -0.012256252661779, -0.012628442265164, -0.012492109402301, -0.011900378652231, -0.010915938299346, -0.009608659754377, -0.008053088974399, -0.006325897265309, -0.004503377492142, -0.002659067367622, -0.000861574371806, 0.000827332693117, 0.002354312074725, 0.003675677035175, 0.004758237193654, 0.005579741615708, 0.006128926518330, 0.006405184342137, 0.006417883713502, 0.006185381042793, 0.005733773814525, 0.005095452739705, 0.004307514670913, 0.003410100434815, 0.002444721520729, 0.001452636978127, 0.000473337108736, -0.000456816143709, -0.001305750470582, -0.002046613979126, -0.002658453577603, -0.003126629692687, -0.003442966611022, -0.003605647830262, -0.003618875055162, -0.003492317556571, -0.003240385260682, -0.002881363955309, -0.002436454265641, -0.001928757515418, -0.001382251277128, -0.000820795423197, -0.000267205979747, 0.000257570729758, 0.000735157023334, 0.001150295869854, 0.001491243021705, 0.001749993525741, 0.001922343905181, 0.002007797896986, 0.002009329526382, 0.001933022294688, 0.001787607188751, 0.001583924982830, 0.001334339844517, 0.001052131577239, 0.000750892987202, 0.000443956953222, 0.000143874945326, -0.000138034843911, -0.000392055725587, -0.000610347544621, -0.000787123564187, -0.000918728778670, -0.001003623480387, -0.001042279713182, -0.001037001469981, -0.000991682024643, -0.000911513561154, -0.000802665244132, -0.000671946069805, -0.000526468287945, -0.000373325965839, -0.000219301475042, -0.000070610440491, 0.000067306866594, 0.000189942445319, 0.000293823315792, 0.000376560303152, 0.000436845512435, 0.000474403291421, 0.000489901219629, 0.000484828948652, 0.000461353522453, 0.000422160122440, 0.000370287032130, 0.000308963042891, 0.000241454587464, 0.000170928667750, 0.000100336223447, 0.000032319059134, -0.000030858100724, -0.000087350341501, -0.000135751325952, -0.000175090488591, -0.000204811930038, -0.000224738886845, -0.000235027960953, -0.000236117313675, -0.000228672784217, -0.000213535418872, -0.000191673242401, -0.000164139324162, -0.000132037349181, -0.000096495060236, -0.000058645149734, -0.000019612501893};
  void UnpackAudio( int16_t* buffer) 
  {    
    uint16_t* outBuf = dac0.getWriteBuffer();
    float32_t signal[16];
    arm_q15_to_float (buffer,signal,16);    
    arm_fir_f32(&S1k, signal,signal , BLOCK_SIZE);
  
    for(int i=0;i<16;i++)
    {
      //multiply by 8192 (32768/4) to get the values into the correct range
      outBuf[i] = roundf(min(4095,signal[i]*8192));      
    }    
  //   Serial.write((char*)buffer,32);
   //  Serial.print("\r\n");
  }

  int16_t buffer[Shared::PACKET_SIZE];
  void Setup(void (*copyDataToBuffer)(void*,int), int samplesPerChannel) 
  {      
    
    arm_fir_init_f32(&S1k, NUM_TAPS_1k, coeffs1k, firStateF321k, BLOCK_SIZE); 
    copyDataToBufferFPtr = copyDataToBuffer;

    //init the DAC0 on the DMA controller
    if (!dac0.init(AN_RESOLUTION_12, samplesPerChannel)) 
    {
      Serial.println("Failed to start DAC0 !");   
    }
    
    //get some data just before we kick it off
    copyDataToBufferFPtr(buffer,Shared::PACKET_SIZE);
    //unpack it
    UnpackAudio(buffer);
    //start
    dac0.start();
    //we already know that the 2nd 1/2 of the circular buffer must be filled up before the 1st 1/2 has completed so lets get on with it
    copyDataToBufferFPtr(buffer,Shared::PACKET_SIZE);
    UnpackAudio(buffer);
  }

  void WriteAudioToDMABuffer() 
  {
    //wait for next buffer to come through
   
    
    copyDataToBufferFPtr(buffer,Shared::PACKET_SIZE);  
    //as soon as DMA interrupt for the next block of data occurs we can then copy that to the buffer with a bit of processing in the middle
    while (!dac0.writeRequired()) {}
    UnpackAudio(buffer);
    dac0.writeCompleted();
    
    even = !even;
   
  }
}